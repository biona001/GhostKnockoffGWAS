var documenterSearchIndex = {"docs":
[{"location":"man/FAQ/#Common-questions-and-Answers","page":"FAQ","title":"Common questions and Answers","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"Here is a collection of common questions & answers. If you have a question not listed here, do not hesitate to open a new issue on Github. ","category":"page"},{"location":"man/FAQ/#How-do-I-obtain-Z-scores-from-p-values,-effect-sizes,-odds-ratios...etc?","page":"FAQ","title":"How do I obtain Z-scores from p-values, effect sizes, odds-ratios...etc?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"See the Notes on computing Z-scores section of this blog post","category":"page"},{"location":"man/FAQ/#Expected-run-time?","page":"FAQ","title":"Expected run time?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"On roughly 0.6 million Z-scores, our software completed a GhostKnockoff analysis in roughly 15 minutes on a single 2.3GHz CPU. If your analysis is taking much longer than this, please see Q&A on software unexpectedly slow.","category":"page"},{"location":"man/FAQ/#Software-unexpectedly-slow?","page":"FAQ","title":"Software unexpectedly slow?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"Because the knockoff pipeline requires reading the pre-computed knockoff statistics sequentially into memory, both the downloaded software and data should be stored at a high speed (e.g. Lustre) file system. On most HPC clusters, one should store the data in the SCRATCH directory to run GhostKnockoffGWAS. ","category":"page"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"To check whether I/O is the bottleneck, one can check the CPU usage while GhostKnockoffGWAS is running. For example, one can examine CPU usage via the top or htop command. CPU usage should almost always be at 99% or above.  ","category":"page"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"For undiagnosed performance issues, please file a new issue. ","category":"page"},{"location":"man/FAQ/#Memory-requirement?","page":"FAQ","title":"Memory requirement?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"Our software requires ~9.1GB of RAM on an Alzheimer's Diseases anslysis with ~0.6 million SNPs. ","category":"page"},{"location":"man/FAQ/#Sex-chromosome-support?","page":"FAQ","title":"Sex chromosome support?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"We currently do not support X/Y/M chromosome analysis.","category":"page"},{"location":"man/FAQ/#Non-European-knockoff-statistics?","page":"FAQ","title":"Non-European knockoff statistics?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"We will release more pre-computed knockoff statistics for download, once we tested and verified the methodology against suitable datasets. Most likely, the first non-EUR release will be on African and East Asian populations. ","category":"page"},{"location":"man/FAQ/#How-do-I-specify-my-own-groups?","page":"FAQ","title":"How do I specify my own groups?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"We will add this feature in the near future","category":"page"},{"location":"man/developer/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"This is for advanced users who wish to build customized knockoff analysis pipelines. Currently, customization is not easy, but it is possible in principle at 2 levels: ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Constructing knockoff statistics for custom LD panels, including\nSpecifying which LD panel to use\nDefining quasi-independent regions and groups\nSolving the knockoff (convex) optimization problem\nSaving the result in a easy-to-read format, which will be read in step 2\nGhost Knockoff sampling and high dimensional Lasso regression\nRead pre-computed knockoff statistics from step 1\nSample Ghost Knockoffs\nFit a pseudo-lasso problem\nApplying the knockoff filter","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"If you would like assistance on any of these steps, feel free to reach out to us. ","category":"page"},{"location":"man/developer/#Constructing-knockoff-statistics-for-custom-LD-panels","page":"Developer documentation","title":"Constructing knockoff statistics for custom LD panels","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Processing of LD panels (including downloading and importing the data matrices) is carried out by EasyLD.jl. This package should make it easy to import a region of the LD matrix into memory in Julia.\nTo partition the extremely large LD matrix into manageable pieces, we directly adopted the output of ldetect for which AFR (african), ASN (east Asians), and EUR (european) results are already available (position coordinates are given in HG19). \nKnockoff optimization problem was carried out by Knockoffs.jl.","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Because pre-computed knockoff statistics are available for download, users do not have to manually install EasyLD.jl nor Knockoffs.jl to carry out this step.","category":"page"},{"location":"man/developer/#Ghost-Knockoff-sampling-and-high-dimensional-Lasso-regression","page":"Developer documentation","title":"Ghost Knockoff sampling and high dimensional Lasso regression","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Over 1703 quasi-independent blocks, we have assembled \\begin{align}     \\Sigma =     \\begin{bmatrix}         \\Sigma1 & & \\\n        & \\ddots & \\\n        & & \\Sigma{1703}     \\end{bmatrix}, \\quad     S =      \\begin{bmatrix}         S1 & & \\\n        & \\ddots & \\\n        & & S{1703}     \\end{bmatrix}, \\quad     Si =      \\begin{bmatrix}         S{i,1} & & \\\n        & \\ddots & \\\n        & & S{i,Gi}     \\end{bmatrix} \\end{align} where Sigma_i are LD matrices obtained from the Pan-UKBB panel and S_i is the group-block-diagonal matrices obtained by solving the knockoff optimization problem. Given a Z-score vector z, we can compute r = frac1sqrtn z, and ghostbasil will solve the following optimization problem with lambda ge 0 p_i ge 0, and 0 le alpha le 1.","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"\\begin{align} \\min \\frac{1}{2}\\beta^t A \\beta - \\beta^tr + \\lambda\\sumipi\\left(\\alpha|\\betai| + \\frac{1-\\alpha}{2}\\betai^2\\right) \\end{align}","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"In GhostKnockoffGWAS, we set alpha = 1 (i.e. a Lasso problem) and p_i = 1 for all i. A = frac1nXtildeXXtildeX and beta contains the effect size for both original variables and their knockoffs. ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"To solve this problem, we leverage the fact that Lasso's objective is seprable over the blocks: as long as we can find a lambda sequence to be used for all blocks, we can fit each block separately. Since the max lambda is only related to the marginal correlation between each feature and y, and the knockoffs are exchangeable to the original features, we can use the original genome-wide Z-scores to compute the lambda sequence. ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Thus, for each block i in 11703, we will call ghostbasil(Bi, r) where \\begin{align}     Bi &= \\text{BlockGroupGhostMatrix}(Ci, Si, m+1)\\\n    Ci &= \\Sigmai - Si \\end{align}   Note that, since we use representative variant approach, S_i is generally a dense matrix. To input a dense matrix, we use Jame's function BlockGroupGhostMatrix with a single block.  \\begin{align}     Bi = \\text{BlockGroupGhostMatrix}(Ci, Si, m+1) =      \\begin{bmatrix}         Ci+Si & Ci & ... & Ci\\\n        Ci & Ci+Si & ... & \\\n        \\vdots & & \\ddots & \\vdots\\\n        Ci & Ci & & Ci + Si     \\end{bmatrix} \\end{align} with the understanding that B_i is the covariance matrix for (Z tildeZ_1tildeZ_m) \\begin{align}     Bi =      \\begin{bmatrix}         \\Sigmai & \\Sigmai-Si & ... & \\Sigmai-Si\\\n        \\Sigmai-Si & \\Sigmai & ... & \\\n        \\vdots & & \\ddots & \\vdots\\\n        \\Sigmai-Si & \\Sigmai-Si & & \\Sigmai     \\end{bmatrix} =      \\begin{bmatrix}         Ci+Si & Ci & ... & Ci\\\n        Ci & Ci+Si & ... & \\\n        \\vdots & & \\ddots & \\vdots\\\n        Ci & Ci & & Ci + S_i     \\end{bmatrix} \\end{align} where C_i = Sigma_i - S_i. In Julia, this functionality is supported via the Ghostbasil.jl package. ","category":"page"},{"location":"man/developer/#Compiling-the-binaries","page":"Developer documentation","title":"Compiling the binaries","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Make sure gcc is available. We recommend version 7.1, but avoid using GCC 11+.\nMake sure GhostKnockoffGWAS is installed within Julia. \ndev the package via","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"]dev GhostKnockoffGWAS","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"compile using PackageCompiler.jl","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"using PackageCompiler, GhostKnockoffGWAS\nsrc = normpath(pathof(GhostKnockoffGWAS), \"../..\")\ndes = normpath(pathof(GhostKnockoffGWAS), \"../../app_linux_x86\")\nprecompile_script = normpath(pathof(GhostKnockoffGWAS), \"../precompile.jl\")\n@time create_app(src, des, \n    include_lazy_artifacts=true, \n    force=true, \n    precompile_execution_file=precompile_script\n)","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"The last step takes 1-2 hours. ","category":"page"},{"location":"man/getting_started/#Getting-started-with-Ghost-Knockoff-GWAS-analysis","page":"Getting started","title":"Getting started with Ghost Knockoff GWAS analysis","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"This tutorial is for generating Ghost Knockoffs for analyzing summary statistics from a genome-wide association studies (GWAS). The methodology is described in the following papers","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"He Z, Liu L, Belloy ME, Le Guen Y, Sossin A, Liu X, Qi X, Ma S, Gyawali PK, Wyss-Coray T, Tang H. GhostKnockoff inference empowers identification of putative causal variants in genome-wide association studies. Nature Communications. 2022 Nov 23;13(1):7209.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The main working assumption is that we do not have access to individual level genotype or phenotype data. Rather, for each SNP, we have","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Z-scores Z_j with respect to some phenotype from a GWAS, and\nAccess to LD (linkage disequilibrium) matrix","category":"page"},{"location":"man/getting_started/#Typical-Workflow","page":"Getting started","title":"Typical Workflow","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Most users are expected to follow this workflow. Those familiar with the Julia programming language can use GhostKnockoffGWAS as a regular julia package, see usage within Julia.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Download the binary executable file (XXX GB)\nDownload the pre-computed knockoff statistics (8.2GB)\nUnzip both datasets\nPrepare your input Z score file into accepted format, see Acceptable Z-scores below. \nRun the executable, see running the executable","category":"page"},{"location":"man/getting_started/#Running-the-executable","page":"Getting started","title":"Running the executable","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"usage: <PROGRAM> --zfile ZFILE --knockoff-dir KNOCKOFF-DIR --N N\n                 --genome-build GENOME-BUILD --out OUT [--seed SEED]\n                 [-h]\n\n  --zfile ZFILE         Tab or comma separated summary Z-score file,\n                        which can be .gz compressed. The first row\n                        must be a header line that contains at least\n                        CHR, POS, REF, ALT, and Z (other columns will\n                        be ignored). Each row should be a SNP. CHR is\n                        the chromosome column and must be integer\n                        valued (e.g. chr22 is NOT valid). POS is the\n                        position of the SNP (aligned to HG19 or HG38).\n                        REF and ALT are the reference and alternate\n                        alleles, which will be treated as the\n                        non-effective and effect alleles,\n                        respectively. Finally Z is the Z-score column\n  --knockoff-dir KNOCKOFF-DIR\n                        Path to the directory storing pre-processed\n                        knockoff files\n  --N N                 Sample size for target (original) study (type:\n                        Int64)\n  --genome-build GENOME-BUILD\n                        Specifies the human genome build for the\n                        target (original) study. Must be 19 (hg19) or\n                        38 (hg38). (type: Int64)\n  --out OUT             Output file prefix (without extensions)\n  --seed SEED           Sets the random seed (type: Int64, default:\n                        2023)\n  -h, --help            show this help message and exit","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Example run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"./GhostKnockoffGWAS \\\n    --zfile ../../data/AD_Zscores_Meta_modified.txt \\\n    --knockoff-dir ../../data/EUR \\\n    --N 506200 \\\n    --genome-build 38 \\\n    --out ../../data/test_alzheimers_meta","category":"page"},{"location":"man/getting_started/#Acceptable-Z-scores-file-format","page":"Getting started","title":"Acceptable Z-scores file format","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The Z score file should satisfy the following requirements:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"It is a comma- or tab-separated file (.gz compressed is acceptable)\nThe first row should be a header line, and every row after the first will be treated as a different SNP. \nThe header line should include CHR, POS, REF, ALT, and Z. The ALT allele will be treated as the effect allele and REF be treated as non-effect allele. The POS (position) field of each variant must be from HG19 or HG38, which must be specified by the --genome-build argument. CHR/POS/REF/ALT fields cannot have missing values. Missing Z scores can be specified as NaN or as an empty cell.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you have p-values, effect sizes, odds ratios...etc but not Z scores, you can convert them into Z score, for example by following the Notes on computing Z-scores of this blog post. ","category":"page"},{"location":"man/julia/#Usage-within-Julia","page":"Usage within Julia","title":"Usage within Julia","text":"","category":"section"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"GhostKnockoffGWAS is a regular Julia package, which can be used directly within Julia for greater flexibility. To install it, execute the following in Julia","category":"page"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"using Pkg\nPkg.add(url=\"https://github.com/biona001/ghostbasil_jll.jl\")\nPkg.add(url=\"https://github.com/biona001/Ghostbasil.jl\")\nPkg.add(url=\"https://github.com/biona001/GhostKnockoffGWAS\")","category":"page"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"warning: Warning\nThis package currently only works on Julia 1.8.x and 1.9.x. If you need it to work on a different Julia version, let us know by filing an issue on Github. ","category":"page"},{"location":"man/julia/#Usage-example","page":"Usage within Julia","title":"Usage example","text":"","category":"section"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"The following example performs summary-statistics GWAS under the GhostKnockoff framework.","category":"page"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"using GhostKnockoffGWAS\n\n# file paths and directories\nknockoff_dir = \"/home/groups/sabatti/.julia/dev/GhostKnockoffGWAS/data/EUR\"\nzfile = \"/home/groups/sabatti/.julia/dev/GhostKnockoffGWAS/data/AD_Zscores_Meta_modified.txt\"\noutdir = \"/home/groups/sabatti/.julia/dev/GhostKnockoffGWAS/data\"\noutfile = \"test_alzheimers_meta\"\n\n# specify sample size and human genome build\nN = 506200\nhg_build = 38\n\n# read Z-scores using built-in function read_zscores\nz, chr, pos, effect_allele, non_effect_allele = GhostKnockoffGWAS.read_zscores(zfile)\n\n# run analysis\n@time ghostbasil_parallel(knockoff_dir, z, chr, pos, effect_allele, \n    non_effect_allele, N, hg_build, outdir, outname=outfile, \n    seed=2023)","category":"page"},{"location":"man/julia/#Function-API","page":"Usage within Julia","title":"Function API","text":"","category":"section"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"Modules = [GhostKnockoffGWAS]\nOrder   = [:function, :type]","category":"page"},{"location":"man/julia/#GhostKnockoffGWAS.MK_statistics-Union{Tuple{T}, Tuple{Vector{T}, Array{Vector{T}, 1}}} where T","page":"Usage within Julia","title":"GhostKnockoffGWAS.MK_statistics","text":"MK_statistics(T0::Vector, Tk::Vector{Vector}; filter_method)\n\nComputes the multiple knockoff statistics kappa, tau, and W. \n\nInputs\n\nT0: p-vector of importance score for original variables\nTk: Vector storing T1, ..., Tm, where Ti is importance scores for    the ith knockoff copy\nfilter_method: Either Statistics.median (default) or max (original    function used in 2019 Gimenez and Zou)\n\noutput\n\nκ: Index of the most significant feature (κ[i] = 0 if original feature most    important, otherwise κ[i] = k if the kth knockoff is most important)\nτ: τ[i] stores the most significant statistic among original and knockoff   variables minus filter_method() applied to the remaining statistics. \nW: coefficient difference statistic W[i] = abs(T0[i]) - abs(Tk[i])\n\nSource\n\nhttps://github.com/biona001/Knockoffs.jl/blob/master/src/threshold.jl#L96\n\n\n\n\n\n","category":"method"},{"location":"man/julia/#GhostKnockoffGWAS.find_matching_indices-Tuple{AbstractVector, AbstractVector}","page":"Usage within Julia","title":"GhostKnockoffGWAS.find_matching_indices","text":"find_matching_indices(a, b)\n\nReturns output vector c such that c[i] contains all indices of b that  matches a[i]. Generalizes indexin in Base. \n\nExample\n\na = [1, 2, 3, 2, 6]\nb = [2, 1, 2, 4, 3]\nc = find_matching_indices(a, b)\nprintln(c)  # Output: [[2], [1, 3], [5], [1, 3], Int[]]\n\n\n\n\n\n","category":"method"},{"location":"man/julia/#GhostKnockoffGWAS.ghost_knockoffs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T","page":"Usage within Julia","title":"GhostKnockoffGWAS.ghost_knockoffs","text":"ghost_knockoffs(Zscores, D, Σinv; [m=1])\n\nGenerate Ghost knockoffs given a list of z-scores (GWAS summary statistic). \n\nInputs\n\nZscores: List of z-score statistics\nD: Matrix obtained from solving the knockoff problem satisfying    (m+1)/m*Σ - D ⪰ 0\nΣinv: Inverse of the covariance matrix\n\noptional inputs\n\nm: Number of knockoffs\n\nReference\n\nHe, Z., Liu, L., Belloy, M. E., Le Guen, Y., Sossin, A., Liu, X., ... & Ionita-Laza, I. (2021).  Summary statistics knockoff inference empowers identification of putative causal variants in  genome-wide association studies. \n\nSource\n\nhttps://github.com/biona001/Knockoffs.jl/blob/master/src/ghost.jl#L32\n\n\n\n\n\n","category":"method"},{"location":"man/julia/#GhostKnockoffGWAS.mk_threshold-Union{Tuple{T}, Tuple{Vector{T}, Vector{Int64}, Int64, Number}, Tuple{Vector{T}, Vector{Int64}, Int64, Number, Any}, Tuple{Vector{T}, Vector{Int64}, Int64, Number, Any, Int64}} where T<:AbstractFloat","page":"Usage within Julia","title":"GhostKnockoffGWAS.mk_threshold","text":"mk_threshold(τ::Vector{T}, κ::Vector{Int}, m::Int, q::Number)\n\nChooses the multiple knockoff threshold τ̂ > 0 by setting τ̂ = min{ t > 0 : (1/m + 1/m * {#j: κ[j] ≥ 1 and W[j] ≥ t}) / {#j: κ[j] == 0 and W[j] ≥ τ̂} ≤ q }.\n\nInputs\n\nτ: τ[i] stores the feature importance score for the ith feature, i.e. the value   T0 - median(T1,...,Tm). Note in Gimenez and Zou, the max function is used    instead of median\nκ: κ[i] stores which of m knockoffs has largest importance score. When original    variable has largest score, κ[i] == 0.\nm: Number of knockoffs per variable generated\nq: target FDR (between 0 and 1)\nrej_bounds: Number of values of top τ to consider (default = 10000)\n\nReference:\n\nEquations 8 and 9 in supplement of \"Identification of putative causal loci in    wholegenome sequencing data via knockoff statistics\" by He et al. \nAlgorithm 1 of \"Improving the Stability of the Knockoff Procedure: Multiple    Simultaneous Knockoffs and Entropy Maximization\" by Gimenez and Zou.\n\nSource\n\nhttps://github.com/biona001/Knockoffs.jl/blob/master/src/threshold.jl#L55\n\n\n\n\n\n","category":"method"},{"location":"man/julia/#GhostKnockoffGWAS.read_zscores-Tuple{String}","page":"Usage within Julia","title":"GhostKnockoffGWAS.read_zscores","text":"read_zscores(filepath::String)\n\nHelper function to read a Z-score file. First row must be a header column with  CHR, POS, REF, ALT, and Z. All other columns will be ignored. \n\ntodo: detect duplicate SNPs\n\n\n\n\n\n","category":"method"},{"location":"man/julia/#GhostKnockoffGWAS.sample_mvn_efficient-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64}} where T","page":"Usage within Julia","title":"GhostKnockoffGWAS.sample_mvn_efficient","text":"sample_mvn_efficient(C::AbstractMatrix{T}, D::AbstractMatrix{T}, m::Int)\n\nEfficiently samples from N(0, A) where\n\nbeginaligned\nA = beginpmatrix\n    C  C-D  cdots  C-D\n    C-D  C  cdots  C-D\n    vdots   ddots  vdots\n    C-D  C-D   C\nendpmatrix\nendaligned\n\nNote there are m blocks per row/col\n\nSource\n\nhttps://github.com/biona001/Knockoffs.jl/blob/master/src/ghost.jl#L60\n\n\n\n\n\n","category":"method"},{"location":"man/video/#Video-Tutorials","page":"Video tutorials","title":"Video Tutorials","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"Coming soon","category":"page"},{"location":"man/video/#Installation","page":"Video tutorials","title":"Installation","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"","category":"page"},{"location":"man/video/#Running-the-analysis","page":"Video tutorials","title":"Running the analysis","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"","category":"page"},{"location":"man/video/#Interpreting-the-result","page":"Video tutorials","title":"Interpreting the result","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"","category":"page"},{"location":"man/examples/#Detailed-Example","page":"Examples","title":"Detailed Example","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"This page collect examples of running the ghost knockoff pipeline. We will cover topics such as installation, examining input data, running the software, and visualizing the output. ","category":"page"},{"location":"man/examples/#Step-1:-Download-Knockoff-files-and-binary-executable","page":"Examples","title":"Step 1: Download Knockoff files and binary executable","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Download the binary executable file (XXX GB)\nDownload the [pre-computed knockoff statistics]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The structure of the binary executable folder looks like:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We recommend adding GhostKnockoffGWAS to PATH for easier access.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"man/examples/#Step-2:-Prepare-a-valid-Z-score-file","page":"Examples","title":"Step 2: Prepare a valid Z score file","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Here is an example of a valid Z-score file","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"$ head AD_Zscores_Meta_modified.txt\n\nCHR\tPOS\tREF\tALT\tZ\n1\t758351\tA\tG\t1.05551882016081\n1\t779885\tC\tT\t2.12197306477\n1\t779987\tA\tG\t1.95791489337\n1\t782105\tC\tA\t1.91243829548\n1\t782207\tG\tA\t0.619646889027784\n1\t785001\tG\tT\t2.29540369149\n1\t785910\tG\tC\t2.31560217481\n1\t788511\tG\tC\t-2.46818530405\n1\t791414\tC\tG\t2.35908619469","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The first row is a header row which includes CHR, POS, REF, ALT, Z. Other columns will be ignored. \nEach row is a different SNP and each column is separated by a tab (i.e. \\t character) or a comma","category":"page"},{"location":"man/examples/#Step-3:-Running-the-analysis","page":"Examples","title":"Step 3: Running the analysis","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"man/examples/#Step-4:-Interpreting-the-result","page":"Examples","title":"Step 4: Interpreting the result","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"#GWAS-summary-statistics-analysis-via-Knockoff-filter","page":"Home","title":"GWAS summary statistics analysis via Knockoff-filter","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is package for performing knockoff-based analysis of GWAS summary statistics. The knockoff-filter finds conditionally independent discoveries while controlling the FDR (false discovery rate) to any specified level. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package currently only works on Linux platforms with aarch64 or x86_64 CPUs. We plan to support mac (x86_64 and aarch64) in the near future, but not for windows. ","category":"page"}]
}
