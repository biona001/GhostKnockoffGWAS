var documenterSearchIndex = {"docs":
[{"location":"man/FAQ/#Common-questions-and-Answers","page":"FAQ","title":"Common questions and Answers","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"Here is a collection of common questions & answers. If you have a question not listed here, do not hesitate to open a new issue on Github. ","category":"page"},{"location":"man/FAQ/#How-do-I-obtain-Z-scores-from-p-values,-effect-sizes,-odds-ratios...etc?","page":"FAQ","title":"How do I obtain Z-scores from p-values, effect sizes, odds-ratios...etc?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"See the Notes on computing Z-scores section of this blog post","category":"page"},{"location":"man/FAQ/#Is-the-result-is-trustworthy?","page":"FAQ","title":"Is the result is trustworthy?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"Knockoff's FDR control requires that the correlation matrices used in the analysis approximates the LD structure for the original GWAS study. Their consistency is measured by the mean_LD_shrinkage parameter in the summary output. This value lies between 0 and 1. Values close to 0 indicates good performance. Larger values (e.g. >0.1) indicates deviation. Very larger values (e.g. >0.25) will cause the program to hault and users should download a different set of precomputed knockoff data instead. See equation 24 of the SuSiE paper for details. ","category":"page"},{"location":"man/FAQ/#Expected-run-time?","page":"FAQ","title":"Expected run time?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"On roughly 0.6 million Z-scores, our software completed a GhostKnockoff analysis in roughly 15 minutes on a single 2.3GHz CPU. If your analysis is taking much longer than this, please see Q&A on software unexpectedly slow.","category":"page"},{"location":"man/FAQ/#Memory-requirement?","page":"FAQ","title":"Memory requirement?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"Our software requires ~9.1GB of RAM on an Alzheimer's Diseases anslysis with ~0.6 million SNPs. ","category":"page"},{"location":"man/FAQ/#Software-unexpectedly-slow?","page":"FAQ","title":"Software unexpectedly slow?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"Because the knockoff pipeline requires reading the pre-computed knockoff statistics sequentially into memory, both the downloaded software and data should be stored at a high speed (e.g. Lustre) file system. On most HPC clusters, one should store the data in the SCRATCH directory to run GhostKnockoffGWAS. ","category":"page"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"To check whether I/O is the bottleneck, one can check the CPU usage while GhostKnockoffGWAS is running. For example, one can examine CPU usage via the top or htop command. CPU usage should almost always be at 99% or above.  ","category":"page"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"For undiagnosed performance issues, please file a new issue. ","category":"page"},{"location":"man/FAQ/#Sex-chromosome-support?","page":"FAQ","title":"Sex chromosome support?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"We currently do not support X/Y/M chromosome analysis.","category":"page"},{"location":"man/FAQ/#Non-European-knockoff-statistics?","page":"FAQ","title":"Non-European knockoff statistics?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"We will release more pre-computed knockoff statistics for download, once we tested and verified the methodology against suitable datasets. Most likely, the first non-EUR release will be on African and East Asian populations. ","category":"page"},{"location":"man/FAQ/#How-do-I-specify-my-own-groups?","page":"FAQ","title":"How do I specify my own groups?","text":"","category":"section"},{"location":"man/FAQ/","page":"FAQ","title":"FAQ","text":"We will add this feature in the near future","category":"page"},{"location":"man/developer/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"This is for advanced users who wish to build customized knockoff analysis pipelines. Currently, customization is not easy, but it is possible in principle at 2 levels: ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Constructing knockoff statistics for custom LD panels, including\nSpecifying which LD panel to use\nDefining quasi-independent regions and groups\nSolving the knockoff (convex) optimization problem\nSaving the result in a easy-to-read format, which will be read in step 2\nGhost Knockoff sampling and high dimensional Lasso regression\nRead pre-computed knockoff statistics from step 1\nSample Ghost Knockoffs\nFit a pseudo-lasso problem\nApplying the knockoff filter","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"A full example is provided in 3 separate jupyter notebooks: part 0, part 1, and part 2. If you need assistance on any of these steps, feel free to reach out to us. ","category":"page"},{"location":"man/developer/#1.-Constructing-knockoff-statistics-for-custom-LD-panels","page":"Developer documentation","title":"1. Constructing knockoff statistics for custom LD panels","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"This section gives a high-level overview up to part 1 of the GhostKnockoff pipeline (computation of knockoff statistics). ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Processing of LD panels (including downloading and importing the data matrices) is carried out by EasyLD.jl. This package should make it easy to import a region of the LD matrix into memory in Julia. \nTo partition the extremely large LD matrix into manageable pieces, we directly adopted the output of ldetect for which AFR (african), ASN (east Asians), and EUR (european) results are already available (position coordinates are given in HG19). For the EUR panel, the autosomes are partitioned into 1703 \"quasi-independent\" regions, see Figure S2 of this paper for summaries. \nKnockoff optimization problem was carried out by Knockoffs.jl. In particular, we defined groups via average-linkage hierarchical clustering, chose group-key variants within each group via Algorithm A1 in the paper with threshold value c=05, and employed the maximum-entropy group-knockoff solver.","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"For details, please see section 5.1 and 5.2 of this paper. Note that the precomputed knockoff statistics includes everything up to this point. ","category":"page"},{"location":"man/developer/#2.-Ghost-Knockoff-sampling-and-high-dimensional-Lasso-regression","page":"Developer documentation","title":"2. Ghost Knockoff sampling and high dimensional Lasso regression","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Over 1703 quasi-independent blocks, we have assembled","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginaligned\n    Sigma =\n    beginbmatrix\n        Sigma_1   \n         ddots  \n          Sigma_1703\n    endbmatrix quad\n    S = \n    beginbmatrix\n        S_1   \n         ddots  \n          S_1703\n    endbmatrix quad\n    S_i = \n    beginbmatrix\n        S_i1   \n         ddots  \n          S_iG_i\n    endbmatrix\nendaligned","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"where Sigma_i are LD matrices obtained from the Pan-UKBB panel and S_i is the group-block-diagonal matrices obtained by solving the knockoff optimization problem. Given a Z-score vector z, we can compute r = frac1sqrtn z, and ghostbasil will solve the following optimization problem with lambda ge 0 p_i ge 0, and 0 le alpha le 1.","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginaligned\n    min frac12beta^t A beta - beta^tr + lambdasum_ip_ileft(alphabeta_i + frac1-alpha2beta_i^2right)\nendaligned","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"In GhostKnockoffGWAS, we set alpha = 1 (i.e. a Lasso problem) and p_i = 1 for all i. A = frac1nXtildeXXtildeX and beta contains the effect size for both original variables and their knockoffs. ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"To solve this problem, we leverage the fact that Lasso's objective is seprable over the blocks: as long as we can find a lambda sequence to be used for all blocks, we can fit each block separately. Since the max lambda is only related to the marginal correlation between each feature and y, and the knockoffs are exchangeable to the original features, we can use the original genome-wide Z-scores to compute the lambda sequence. ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Thus, for each block i in 11703, we will call ghostbasil(Bi, r) where","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginaligned\n    B_i = textBlockGroupGhostMatrix(C_i S_i m+1)\n    C_i = Sigma_i - S_i\nendaligned  ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Note that, since we use representative variant approach, S_i is generally a dense matrix. To input a dense matrix, we use Jame's function BlockGroupGhostMatrix with a single block. ","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginaligned\n    B_i = textBlockGroupGhostMatrix(C_i S_i m+1) = \n    beginbmatrix\n        C_i+S_i  C_i    C_i\n        C_i  C_i+S_i    \n        vdots   ddots  vdots\n        C_i  C_i   C_i + S_i\n    endbmatrix\nendaligned","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"with the understanding that B_i is the covariance matrix for (Z tildeZ_1tildeZ_m)","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginaligned\n    B_i = \n    beginbmatrix\n        Sigma_i  Sigma_i-S_i    Sigma_i-S_i\n        Sigma_i-S_i  Sigma_i    \n        vdots   ddots  vdots\n        Sigma_i-S_i  Sigma_i-S_i   Sigma_i\n    endbmatrix = \n    beginbmatrix\n        C_i+S_i  C_i    C_i\n        C_i  C_i+S_i    \n        vdots   ddots  vdots\n        C_i  C_i   C_i + S_i\n    endbmatrix\nendaligned","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"where C_i = Sigma_i - S_i. In Julia, this functionality is supported via the Ghostbasil.jl package. ","category":"page"},{"location":"man/developer/#Compiling-the-binaries","page":"Developer documentation","title":"Compiling the binaries","text":"","category":"section"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"Make sure gcc is available. We recommend version 7.1, but avoid using GCC 11+.\nMake sure GhostKnockoffGWAS is installed within Julia. \ndev the package via","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"]dev GhostKnockoffGWAS","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"compile using PackageCompiler.jl","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"using PackageCompiler, GhostKnockoffGWAS\nsrc = normpath(pathof(GhostKnockoffGWAS), \"../..\")\ndes = normpath(pathof(GhostKnockoffGWAS), \"../../app_linux_x86\")\nprecompile_script = normpath(pathof(GhostKnockoffGWAS), \"../precompile.jl\")\n@time create_app(src, des, \n    include_lazy_artifacts=true, \n    force=true, \n    precompile_execution_file=precompile_script\n)","category":"page"},{"location":"man/developer/","page":"Developer documentation","title":"Developer documentation","text":"The last step takes 1-2 hours. ","category":"page"},{"location":"man/getting_started/#Getting-started-with-Ghost-Knockoff-GWAS-analysis","page":"Getting started","title":"Getting started with Ghost Knockoff GWAS analysis","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"This tutorial is for generating Ghost Knockoffs for analyzing summary statistics from a genome-wide association studies (GWAS). The methodology is described in the following papers","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"He Z, Liu L, Belloy ME, Le Guen Y, Sossin A, Liu X, Qi X, Ma S, Gyawali PK, Wyss-Coray T, Tang H. GhostKnockoff inference empowers identification of putative causal variants in genome-wide association studies. Nature Communications. 2022 Nov 23;13(1):7209.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The main working assumption is that we do not have access to individual level genotype or phenotype data. Rather, for each SNP, we have","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Z-scores Z_j with respect to some phenotype from a GWAS, and\nAccess to LD (linkage disequilibrium) matrix","category":"page"},{"location":"man/getting_started/#Q:-When-should-I-use-GhostKnockoffGWAS?","page":"Getting started","title":"Q: When should I use GhostKnockoffGWAS?","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Answer: If you have already conducted a GWAS and have an output file that includes Z scores (or equivalent) for each SNP.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If instead you have individual level genotypes, you should run a GWAS using standard tools (e.g. BOLT, GCTA, SAIGE, GEMMA, ...etc) before running GhostKnockoffGWAS.","category":"page"},{"location":"man/getting_started/#Typical-Workflow","page":"Getting started","title":"Typical Workflow","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Most users are expected to follow this workflow. Those familiar with the Julia programming language can use GhostKnockoffGWAS as a regular julia package, see usage within Julia.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Download the binary executable file (XXX GB)\nDownload the pre-computed knockoff statistics (8.2GB)\nUnzip both datasets\nPrepare your input Z score file into accepted format, see Acceptable Z-scores below. \nRun the executable, see running the executable","category":"page"},{"location":"man/getting_started/#Running-the-executable","page":"Getting started","title":"Running the executable","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"usage: <PROGRAM> --zfile ZFILE --knockoff-dir KNOCKOFF-DIR --N N\n                 --genome-build GENOME-BUILD --out OUT [--seed SEED]\n                 [--verbose VERBOSE]\n                 [--skip_shrinkage_check SKIP_SHRINKAGE_CHECK] [-h]\n\noptional arguments:\n  --zfile ZFILE         Tab or comma separated summary Z-score file,\n                        which can be .gz compressed. The first row\n                        must be a header line that contains at least\n                        CHR, POS, REF, ALT, and Z (other columns will\n                        be ignored). Each row should be a SNP. CHR is\n                        the chromosome column and must be integer\n                        valued (e.g. chr22, , sex chromosomes, and\n                        missing values are NOT valid). POS is the SNP\n                        (aligned to HG19 or HG38) and cannot be\n                        missing. REF the position of and ALT are the\n                        reference and alternate alleles, which will be\n                        treated as the non-effective and effect\n                        alleles, respectively, and also cannot be\n                        missing. Finally, Z is the Z-score column.\n                        Missing Z scores can be specified as NaN or as\n                        an empty cell.\n  --knockoff-dir KNOCKOFF-DIR\n                        Path to the directory storing pre-processed\n                        knockoff files\n  --N N                 Sample size for target (original) study (type:\n                        Int64)\n  --genome-build GENOME-BUILD\n                        Specifies the human genome build for the\n                        target (original) study. Must be 19 (hg19) or\n                        38 (hg38). (type: Int64)\n  --out OUT             Output file prefix (without extensions)\n  --seed SEED           Sets the random seed (type: Int64, default:\n                        2023)\n  --verbose VERBOSE     Whether to print intermediate messages (type:\n                        Bool, default: true)\n  --skip_shrinkage_check SKIP_SHRINKAGE_CHECK\n                        Whether to allow Knockoff analysis to proceed\n                        even with large (>0.25) LD shrinkages. Only\n                        use this option if you know what you are\n                        doing.  (type: Bool, default: true)\n  -h, --help            show this help message and exit","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Example run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"./GhostKnockoffGWAS \\\n    --zfile ../../data/AD_Zscores_Meta_modified.txt \\\n    --knockoff-dir ../../data/EUR \\\n    --N 506200 \\\n    --genome-build 38 \\\n    --out ../../data/test_alzheimers_meta","category":"page"},{"location":"man/getting_started/#Acceptable-Z-scores-file-format","page":"Getting started","title":"Acceptable Z-scores file format","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The Z score file should satisfy the following requirements:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"It is a comma- or tab-separated file (.gz compressed is acceptable)\nThe first row should be a header line, and every row after the first will be treated as a different SNP. \nThe header line should include CHR, POS, REF, ALT, and Z. The ALT allele will be treated as the effect allele and REF be treated as non-effect allele. The POS (position) field of each variant must be from HG19 or HG38, which must be specified by the --genome-build argument. CHR/POS/REF/ALT fields cannot have missing values. Missing Z scores can be specified as NaN or as an empty cell.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you have p-values, effect sizes, odds ratios...etc but not Z scores, you can convert them into Z score, for example by following the Notes on computing Z-scores of this blog post. ","category":"page"},{"location":"man/julia/#Usage-within-Julia","page":"Usage within Julia","title":"Usage within Julia","text":"","category":"section"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"GhostKnockoffGWAS is a regular Julia package, which can be used directly within Julia for greater flexibility. To install it, execute the following in Julia","category":"page"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"using Pkg\nPkg.add(url=\"https://github.com/biona001/ghostbasil_jll.jl\")\nPkg.add(url=\"https://github.com/biona001/Ghostbasil.jl\")\nPkg.add(url=\"https://github.com/biona001/GhostKnockoffGWAS\")","category":"page"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"warning: Warning\nThis package currently only works on Julia 1.8.x and 1.9.x. If you need it to work on a different Julia version, let us know by filing an issue on Github. ","category":"page"},{"location":"man/julia/#Usage-example","page":"Usage within Julia","title":"Usage example","text":"","category":"section"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"The following example performs summary-statistics GWAS under the GhostKnockoff framework.","category":"page"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"using GhostKnockoffGWAS\n\n# file paths and directories\nknockoff_dir = \"/home/groups/sabatti/.julia/dev/GhostKnockoffGWAS/data/EUR\"\nzfile = \"/home/groups/sabatti/.julia/dev/GhostKnockoffGWAS/data/AD_Zscores_Meta_modified.txt\"\noutdir = \"/home/groups/sabatti/.julia/dev/GhostKnockoffGWAS/data\"\n\n# specify sample size and human genome build\nN = 506200\nhg_build = 38\n\n# read Z-scores using built-in function read_zscores\nz, chr, pos, effect_allele, non_effect_allele = GhostKnockoffGWAS.read_zscores(zfile)\n\n# run analysis\n@time ghostknockoffgwas(knockoff_dir, z, chr, pos, effect_allele, \n    non_effect_allele, N, hg_build, outdir, outname=\"test_alzheimers_meta\")","category":"page"},{"location":"man/julia/#Function-API","page":"Usage within Julia","title":"Function API","text":"","category":"section"},{"location":"man/julia/","page":"Usage within Julia","title":"Usage within Julia","text":"ghostknockoffgwas\nread_zscores","category":"page"},{"location":"man/julia/#GhostKnockoffGWAS.ghostknockoffgwas","page":"Usage within Julia","title":"GhostKnockoffGWAS.ghostknockoffgwas","text":"ghostknockoffgwas(knockoff_dir::String, z::Vector{Float64}, chr::Vector{Int}, \n    effect_allele::Vector{String}, non_effect_allele::Vector{String}, N::Int,\n    hg_build::Int, outdir::String; [outname=\"result\"], [seed=2023], \n    [target_chrs=1:22], [A_scaling_factor = 0.01], [kappa=0.6], \n    [LD_shrinkage=false], [target_fdrs=0.01:0.01:0.2], [verbose=true], \n    [skip_shrinkage_check=false])\n\nRuns the main GhostKnockoffGWAS pipeline on the Z scores in z using  pre-computed knockoff data in knockoff_dir. \n\nInputs\n\nknockoff_dir: Directory that stores pre-computed knockoff results\nz: Vector of Z scores\nchr: Chromosome of each Z score (cannot be X/Y/M chromosomes)\npos: Position of each Z score (specify hg build with hg_build)\neffect_allele: Effect allele of Z score (i.e. ALT)\nnon_effect_allele: Non-effect allele of Z score (i.e. REF)\nN: sample size of original study\nhg_build: Human genome build (must be 19 or 38)\noutdir: output directory, which must exist. We will output 2 files, one    containing the full analysis results, as well as a summary file. \n\nOptional inputs\n\nseed: Random seed for reproducibility (default = 2023)\ntarget_chrs: Target chromosomes to analyze. For example, one can specify   target_chrs = 22 to only analyze 1 chromosome, or target_chrs = [1, 2]   to only analyze 2 chromosomes (default = 1:22).\nA_scaling_factor: The scaling factor for A = [X X̃]'*[X X̃] for improving   numerical stability. Scaling proceeds by adding A_scaling_factor*I to A   (default = 0.01). \nkappa: A constant between 0 and 1 for tuning Lasso's lambda path. Larger   value forces earlier exit in Lasso lambda path, resulting in stronger    shrinkage. See the \"lasso-min\" method of \"Controlled Variable Selection from   Summary Statistics Only? A Solution via GhostKnockoffs and Penalized    Regression\" by Chen et al (default 0.6).\nLD_shrinkage: Whether to perform shrinkage to LD and S matrices following   method in SuSiE paper (i.e. eq 24 of \"Fine-mapping from summary data with    the “Sum of Single Effects” model\" by Zou et al). If false, we will still   compute the shrinkage level, but it will not be used to adjust the LD   matrices (defaultfalse`). \ntarget_fdrs: Default target FDR levels (default = 0.01:0.01:0.2)\nverbose: Whether to print progress and informative intermediate results (   default = true)\nskip_shrinkage_check: Forces a result output even if there is a high   estimated LD shrinkage by SuSiE's method (default = false)\n\nOutput\n\nBy default we output 2 files into outdir\n\nA knockoff statistics file where each SNP occupies a row and the columns include    various SNP attributes include rsid, AF, chr, pos, zscores...etc. The    columns selected_fdr_FDR indicates whether the variant was ultimately   selected under the false discovery rate threshold of FDR.\nA summary statistics file. The first dozens of rows print, for each false    discovery rate threshold FDR, the knockoff threshold τ̂ and the number of   groups that pass this threshold. The next couple of lines print some    parameters used in the knockoff analysis, as well as some timing results. \n\n\n\n\n\n","category":"function"},{"location":"man/julia/#GhostKnockoffGWAS.read_zscores","page":"Usage within Julia","title":"GhostKnockoffGWAS.read_zscores","text":"read_zscores(filepath::String)\n\nHelper function to read a Z-score file at filepath. This function is mainly  intended for Julia users running GhostKnockoffGWAS in the REPL.\n\nInput\n\nfilepath: Full file path to the Z-score file. First row must be a header   column with CHR, POS, REF, ALT, and Z. All other columns will be   ignored.\n\nOutput\n\nz: The Z scores stored in the Z column of filepath\nchr: The chromosome number stored in CHR column of filepath. Only integer   values are allowed.\npos: The position number stored in POS column of filepath.\neffect_allele: The allele stored in ALT column of filepath.\nnon_effect_allele: The allele stored in REF column of filepath.\n\n\n\n\n\n","category":"function"},{"location":"man/video/#Video-Tutorials","page":"Video tutorials","title":"Video Tutorials","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"Coming soon","category":"page"},{"location":"man/video/#Installation","page":"Video tutorials","title":"Installation","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"","category":"page"},{"location":"man/video/#Running-the-analysis","page":"Video tutorials","title":"Running the analysis","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"","category":"page"},{"location":"man/video/#Interpreting-the-result","page":"Video tutorials","title":"Interpreting the result","text":"","category":"section"},{"location":"man/video/","page":"Video tutorials","title":"Video tutorials","text":"","category":"page"},{"location":"man/examples/#Detailed-Example","page":"Examples","title":"Detailed Example","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"This page collect examples of running the ghost knockoff pipeline. We will cover topics such as installation, examining input data, running the software, and visualizing the output. ","category":"page"},{"location":"man/examples/#Step-1:-Download-Knockoff-files-and-binary-executable","page":"Examples","title":"Step 1: Download Knockoff files and binary executable","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Download the binary executable file (XXX GB)\nDownload the [pre-computed knockoff statistics]","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The structure of the binary executable folder looks like:","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"We recommend adding GhostKnockoffGWAS to PATH for easier access.","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"man/examples/#Step-2:-Prepare-a-valid-Z-score-file","page":"Examples","title":"Step 2: Prepare a valid Z score file","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"Here is an example of a valid Z-score file","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"$ head AD_Zscores_Meta_modified.txt\n\nCHR\tPOS\tREF\tALT\tZ\n1\t758351\tA\tG\t1.05551882016081\n1\t779885\tC\tT\t2.12197306477\n1\t779987\tA\tG\t1.95791489337\n1\t782105\tC\tA\t1.91243829548\n1\t782207\tG\tA\t0.619646889027784\n1\t785001\tG\tT\t2.29540369149\n1\t785910\tG\tC\t2.31560217481\n1\t788511\tG\tC\t-2.46818530405\n1\t791414\tC\tG\t2.35908619469","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"The first row is a header row which includes CHR, POS, REF, ALT, Z. Other columns will be ignored. \nEach row is a different SNP and each column is separated by a tab (i.e. \\t character) or a comma","category":"page"},{"location":"man/examples/#Step-3:-Running-the-analysis","page":"Examples","title":"Step 3: Running the analysis","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"man/examples/#Step-4:-Interpreting-the-result","page":"Examples","title":"Step 4: Interpreting the result","text":"","category":"section"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"man/examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"#GWAS-summary-statistics-analysis-via-Knockoff-filter","page":"Home","title":"GWAS summary statistics analysis via Knockoff-filter","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is package for performing knockoff-based analysis of GWAS summary statistics. The knockoff-filter finds conditionally independent discoveries while controlling the FDR (false discovery rate) to any specified level. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package currently only works on Linux platforms with aarch64 or x86_64 CPUs. We plan to support mac (x86_64 and aarch64) in the near future, but not for windows. ","category":"page"}]
}
